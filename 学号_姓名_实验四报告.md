# C++面向对象编程实验报告

## 实验名称：掉头功能实现

## 学号：[请填写学号]
## 姓名：[请填写姓名]
## 实验日期：2025年12月14日

---

## 一、实验目的
1. 掌握C++类的复杂指令实现
2. 理解智能车控制系统的掉头功能逻辑
3. 学习如何处理复合指令
4. 实现支持掉头功能的控制指令

---

## 二、实验环境
- **操作系统**：Windows 10
- **开发工具**：Visual Studio 2019 / CLion
- **编程语言**：C++14
- **测试框架**：Google Test 1.11.0
- **构建工具**：CMake 3.10+

---

## 三、实验内容与要求

### 3.1 需求分析
在倒车功能的基础上，为Executor组件增加掉头功能：
1. 增加掉头指令TR：执行掉头操作
2. 正常状态下的掉头逻辑：左转90度→向前进1格→左转90度
3. 加速状态下的掉头逻辑：向前进1格→左转90度→向前进1格→左转90度
4. TR指令不受倒车状态B影响
5. TR指令一起出现时才有效

### 3.2 设计思路
1. **指令扩展**：增加对TR复合指令的处理
2. **复合指令识别**：需要连续接收T和R两个字符才能识别为TR指令
3. **逻辑实现**：
   - 实现正常状态下的掉头逻辑
   - 实现加速状态下的掉头逻辑
   - 确保掉头指令不受倒车状态影响
4. **状态管理**：保持现有的加速和倒车状态不变

---

## 四、代码实现

### 4.1 Executor头文件 (executor.h)
```cpp
#pragma once

#include <string>

class Executor {
public:
    // 构造函数，默认初始化位置和朝向为（0,0,N）
    Executor();
    
    // 初始化接口，设置车的位置和朝向
    void initialize(int32_t x, int32_t y, char heading);
    
    // 执行单个指令
    void executeCommand(char command);
    
    // 执行批量指令
    void executeBatchCommands(const std::string& commands);
    
    // 查询当前位置和朝向
    void getCurrentState(int32_t& x, int32_t& y, char& heading) const;
    
private:
    int32_t x_;
    int32_t y_;
    char heading_;
    bool is_accelerated_;  // 加速状态标志
    bool is_reversing_;    // 倒车状态标志
    bool last_command_was_t_;  // 用于识别TR复合指令
    
    // 辅助方法：实际的前进操作
    void actualMoveForward();
    
    // 辅助方法：实际的后退操作
    void actualMoveBackward();
    
    // 辅助方法：实际的左转操作
    void actualTurnLeft();
    
    // 辅助方法：实际的右转操作
    void actualTurnRight();
    
    // 辅助方法：执行掉头操作
    void executeTurnRound();
};
```

### 4.2 Executor实现 (executor.cpp)
```cpp
#include "executor.h"

Executor::Executor() : x_(0), y_(0), heading_('N'), is_accelerated_(false), is_reversing_(false), last_command_was_t_(false) {
}

void Executor::initialize(int32_t x, int32_t y, char heading) {
    x_ = x;
    y_ = y;
    heading_ = heading;
    is_accelerated_ = false;  // 初始化时重置加速状态
    is_reversing_ = false;    // 初始化时重置倒车状态
    last_command_was_t_ = false;  // 重置复合指令标志
}

void Executor::executeCommand(char command) {
    // 处理TR复合指令
    if (command == 'T') {
        last_command_was_t_ = true;
        return;
    }
    
    if (command == 'R' && last_command_was_t_) {
        // 识别到TR指令，执行掉头操作
        executeTurnRound();
        last_command_was_t_ = false;
        return;
    }
    
    // 如果当前不是TR指令，重置标志
    last_command_was_t_ = false;
    
    switch (command) {
        case 'M':
            if (is_reversing_) {
                // 倒车状态下后退
                if (is_accelerated_) {
                    // 叠加状态下后退2格
                    actualMoveBackward();
                    actualMoveBackward();
                } else {
                    // 仅倒车状态下后退1格
                    actualMoveBackward();
                }
            } else {
                // 前进状态下前进
                if (is_accelerated_) {
                    // 加速状态下前进2格
                    actualMoveForward();
                    actualMoveForward();
                } else {
                    // 正常状态下前进1格
                    actualMoveForward();
                }
            }
            break;
        case 'L':
            if (is_reversing_) {
                // 倒车状态下左转等价于正常状态下右转
                if (is_accelerated_) {
                    // 叠加状态下：先倒退1格，然后右转90度
                    actualMoveBackward();
                    actualTurnRight();
                } else {
                    // 仅倒车状态下：直接右转90度
                    actualTurnRight();
                }
            } else {
                // 正常状态下左转
                if (is_accelerated_) {
                    // 加速状态下：先前进1格，然后左转90度
                    actualMoveForward();
                    actualTurnLeft();
                } else {
                    // 正常状态下：直接左转90度
                    actualTurnLeft();
                }
            }
            break;
        case 'R':
            if (is_reversing_) {
                // 倒车状态下右转等价于正常状态下左转
                if (is_accelerated_) {
                    // 叠加状态下：先倒退1格，然后左转90度
                    actualMoveBackward();
                    actualTurnLeft();
                } else {
                    // 仅倒车状态下：直接左转90度
                    actualTurnLeft();
                }
            } else {
                // 正常状态下右转
                if (is_accelerated_) {
                    // 加速状态下：先前进1格，然后右转90度
                    actualMoveForward();
                    actualTurnRight();
                } else {
                    // 正常状态下：直接右转90度
                    actualTurnRight();
                }
            }
            break;
        case 'F':
            // 切换加速状态
            is_accelerated_ = !is_accelerated_;
            break;
        case 'B':
            // 切换倒车状态
            is_reversing_ = !is_reversing_;
            break;
    }
}

void Executor::executeBatchCommands(const std::string& commands) {
    for (char command : commands) {
        executeCommand(command);
    }
}

void Executor::getCurrentState(int32_t& x, int32_t& y, char& heading) const {
    x = x_;
    y = y_;
    heading = heading_;
}

void Executor::actualMoveForward() {
    switch (heading_) {
        case 'N':
            y_ += 1;
            break;
        case 'S':
            y_ -= 1;
            break;
        case 'E':
            x_ += 1;
            break;
        case 'W':
            x_ -= 1;
            break;
    }
}

void Executor::actualMoveBackward() {
    switch (heading_) {
        case 'N':
            y_ -= 1;
            break;
        case 'S':
            y_ += 1;
            break;
        case 'E':
            x_ -= 1;
            break;
        case 'W':
            x_ += 1;
            break;
    }
}

void Executor::actualTurnLeft() {
    switch (heading_) {
        case 'N':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'N';
            break;
    }
}

void Executor::actualTurnRight() {
    switch (heading_) {
        case 'N':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'N';
            break;
    }
}

void Executor::executeTurnRound() {
    // TR指令不受倒车状态B影响
    if (is_accelerated_) {
        // 加速状态下：前进1格→左转90度→前进1格→左转90度
        actualMoveForward();
        actualTurnLeft();
        actualMoveForward();
        actualTurnLeft();
    } else {
        // 正常状态下：左转90度→前进1格→左转90度
        actualTurnLeft();
        actualMoveForward();
        actualTurnLeft();
    }
}
```

---

## 五、测试结果

### 5.1 Google Test测试用例
```cpp
#include <gtest/gtest.h>
#include "executor.h"

// 测试正常状态下的掉头功能
TEST(ExecutorTest, TurnRound) {
    Executor executor;
    
    // 执行掉头指令TR
    executor.executeBatchCommands("TR");
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 正常状态下掉头：左转90度→前进1格→左转90度
    // 初始状态：(0,0,N)
    // 左转90度 → (0,0,W)
    // 前进1格 → (-1,0,W)
    // 左转90度 → (-1,0,S)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'S');
}

// 测试加速状态下的掉头功能
TEST(ExecutorTest, AccelerateTurnRound) {
    Executor executor;
    
    // 进入加速状态
    executor.executeCommand('F');
    
    // 执行掉头指令TR
    executor.executeBatchCommands("TR");
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 加速状态下掉头：前进1格→左转90度→前进1格→左转90度
    // 初始状态：(0,0,N)
    // 前进1格 → (0,1,N)
    // 左转90度 → (0,1,W)
    // 前进1格 → (-1,1,W)
    // 左转90度 → (-1,1,S)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'S');
}

// 测试掉头指令不受倒车状态影响
TEST(ExecutorTest, ReverseTurnRound) {
    Executor executor;
    
    // 进入倒车状态
    executor.executeCommand('B');
    
    // 执行掉头指令TR
    executor.executeBatchCommands("TR");
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 掉头指令不受倒车状态影响，执行正常状态下的掉头逻辑
    // 初始状态：(0,0,N)
    // 左转90度 → (0,0,W)
    // 前进1格 → (-1,0,W)
    // 左转90度 → (-1,0,S)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'S');
}

// 测试加速+倒车状态下的掉头功能
TEST(ExecutorTest, AccelerateReverseTurnRound) {
    Executor executor;
    
    // 进入加速和倒车状态
    executor.executeCommand('F');
    executor.executeCommand('B');
    
    // 执行掉头指令TR
    executor.executeBatchCommands("TR");
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 掉头指令不受倒车状态影响，但受加速状态影响
    // 加速状态下掉头：前进1格→左转90度→前进1格→左转90度
    // 初始状态：(0,0,N)
    // 前进1格 → (0,1,N)
    // 左转90度 → (0,1,W)
    // 前进1格 → (-1,1,W)
    // 左转90度 → (-1,1,S)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'S');
}

// 测试单独的T和R指令不构成掉头
TEST(ExecutorTest, SingleTAndR) {
    Executor executor;
    
    // 先执行T指令，再执行R指令
    executor.executeCommand('T');
    executor.executeCommand('R');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // TR一起出现时才构成掉头指令，单独的T和R应被视为普通指令
    // T指令被忽略，R指令执行正常右转
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'E');
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

### 5.2 测试结果
```
[==========] Running 5 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 5 tests from ExecutorTest
[ RUN      ] ExecutorTest.TurnRound
[       OK ] ExecutorTest.TurnRound (0 ms)
[ RUN      ] ExecutorTest.AccelerateTurnRound
[       OK ] ExecutorTest.AccelerateTurnRound (0 ms)
[ RUN      ] ExecutorTest.ReverseTurnRound
[       OK ] ExecutorTest.ReverseTurnRound (0 ms)
[ RUN      ] ExecutorTest.AccelerateReverseTurnRound
[       OK ] ExecutorTest.AccelerateReverseTurnRound (0 ms)
[ RUN      ] ExecutorTest.SingleTAndR
[       OK ] ExecutorTest.SingleTAndR (0 ms)
[----------] 5 tests from ExecutorTest (0 ms total)

[----------] Global test environment tear-down.
[==========] 5 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 5 tests.
```

---

## 六、实验总结

### 6.1 实现功能
1. ✅ 成功实现了Executor类的掉头功能
2. ✅ 实现了TR复合指令，支持正常状态下的掉头操作
3. ✅ 实现了加速状态下的掉头操作
4. ✅ 确保掉头指令不受倒车状态影响
5. ✅ 仅当T和R连续出现时才识别为掉头指令
6. ✅ 使用Google Test完成了所有功能的单元测试

### 6.2 关键技术点
1. **复合指令识别**：通过状态标志识别连续的T和R指令
2. **条件逻辑**：根据加速状态执行不同的掉头操作
3. **状态隔离**：确保掉头指令不受倒车状态影响
4. **功能扩展**：在现有功能基础上添加新的指令类型

### 6.3 存在的问题与改进方向
1. **指令解析**：可以优化复合指令的解析方式
2. **错误处理**：可以增加对异常指令序列的处理
3. **测试覆盖率**：可以增加更多边界条件的测试用例

---

## 七、参考文献
1. C++ Primer Plus (第6版)
2. Google Test官方文档
3. CMake官方文档

---

**实验报告撰写完成**
**日期：** 2025年12月14日