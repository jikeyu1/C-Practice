# C++面向对象编程实验报告

## 实验名称：加速功能实现

## 学号：[请填写学号]
## 姓名：[请填写姓名]
## 实验日期：2025年12月14日

---

## 一、实验目的
1. 掌握C++类的状态管理
2. 理解智能车控制系统的加速功能逻辑
3. 学习如何在现有代码基础上扩展新功能
4. 实现支持加速功能的控制指令

---

## 二、实验环境
- **操作系统**：Windows 10
- **开发工具**：Visual Studio 2019 / CLion
- **编程语言**：C++14
- **测试框架**：Google Test 1.11.0
- **构建工具**：CMake 3.10+

---

## 三、实验内容与要求

### 3.1 需求分析
在基本控制指令的基础上，为Executor组件增加加速功能：
1. 增加加速指令F：进入加速状态
2. 在加速状态下：
   - M：前进2格
   - L：先前进1格，然后左转90度
   - R：先前进1格，然后右转90度
3. 再接收一次F指令，取消加速状态

### 3.2 设计思路
1. **状态管理**：在Executor类中增加is_accelerated_成员变量，用于表示是否处于加速状态
2. **指令扩展**：在executeCommand方法中增加对F指令的处理
3. **逻辑修改**：修改M、L、R指令的处理逻辑，根据加速状态执行不同的操作
4. **状态切换**：每次收到F指令时，切换加速状态

---

## 四、代码实现

### 4.1 Executor头文件 (executor.h)
```cpp
#pragma once

#include <string>

class Executor {
public:
    // 构造函数，默认初始化位置和朝向为（0,0,N）
    Executor();
    
    // 初始化接口，设置车的位置和朝向
    void initialize(int32_t x, int32_t y, char heading);
    
    // 执行单个指令
    void executeCommand(char command);
    
    // 执行批量指令
    void executeBatchCommands(const std::string& commands);
    
    // 查询当前位置和朝向
    void getCurrentState(int32_t& x, int32_t& y, char& heading) const;
    
private:
    int32_t x_;
    int32_t y_;
    char heading_;
    bool is_accelerated_;  // 加速状态标志
    
    // 辅助方法：实际的前进操作
    void actualMoveForward();
    
    // 辅助方法：实际的左转操作
    void actualTurnLeft();
    
    // 辅助方法：实际的右转操作
    void actualTurnRight();
};
```

### 4.2 Executor实现 (executor.cpp)
```cpp
#include "executor.h"

Executor::Executor() : x_(0), y_(0), heading_('N'), is_accelerated_(false) {
}

void Executor::initialize(int32_t x, int32_t y, char heading) {
    x_ = x;
    y_ = y;
    heading_ = heading;
    is_accelerated_ = false;  // 初始化时重置加速状态
}

void Executor::executeCommand(char command) {
    switch (command) {
        case 'M':
            if (is_accelerated_) {
                // 加速状态下前进2格
                actualMoveForward();
                actualMoveForward();
            } else {
                // 正常状态下前进1格
                actualMoveForward();
            }
            break;
        case 'L':
            if (is_accelerated_) {
                // 加速状态下：先前进1格，然后左转90度
                actualMoveForward();
                actualTurnLeft();
            } else {
                // 正常状态下：直接左转90度
                actualTurnLeft();
            }
            break;
        case 'R':
            if (is_accelerated_) {
                // 加速状态下：先前进1格，然后右转90度
                actualMoveForward();
                actualTurnRight();
            } else {
                // 正常状态下：直接右转90度
                actualTurnRight();
            }
            break;
        case 'F':
            // 切换加速状态
            is_accelerated_ = !is_accelerated_;
            break;
    }
}

void Executor::executeBatchCommands(const std::string& commands) {
    for (char command : commands) {
        executeCommand(command);
    }
}

void Executor::getCurrentState(int32_t& x, int32_t& y, char& heading) const {
    x = x_;
    y = y_;
    heading = heading_;
}

void Executor::actualMoveForward() {
    switch (heading_) {
        case 'N':
            y_ += 1;
            break;
        case 'S':
            y_ -= 1;
            break;
        case 'E':
            x_ += 1;
            break;
        case 'W':
            x_ -= 1;
            break;
    }
}

void Executor::actualTurnLeft() {
    switch (heading_) {
        case 'N':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'N';
            break;
    }
}

void Executor::actualTurnRight() {
    switch (heading_) {
        case 'N':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'N';
            break;
    }
}
```

---

## 五、测试结果

### 5.1 Google Test测试用例
```cpp
#include <gtest/gtest.h>
#include "executor.h"

// 测试加速功能
TEST(ExecutorTest, Accelerate) {
    Executor executor;
    
    // 进入加速状态
    executor.executeCommand('F');
    
    // 加速状态下前进2格
    executor.executeCommand('M');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 2);  // 加速状态下前进2格
    EXPECT_EQ(heading, 'N');
}

// 测试加速状态下的左转
TEST(ExecutorTest, AccelerateTurnLeft) {
    Executor executor;
    
    // 进入加速状态
    executor.executeCommand('F');
    
    // 加速状态下左转：先前进1格，然后左转90度
    executor.executeCommand('L');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'W');
}

// 测试加速状态下的右转
TEST(ExecutorTest, AccelerateTurnRight) {
    Executor executor;
    
    // 进入加速状态
    executor.executeCommand('F');
    
    // 加速状态下右转：先前进1格，然后右转90度
    executor.executeCommand('R');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 1);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'E');
}

// 测试加速状态切换
TEST(ExecutorTest, AccelerateToggle) {
    Executor executor;
    
    // 进入加速状态
    executor.executeCommand('F');
    executor.executeCommand('M');
    
    // 退出加速状态
    executor.executeCommand('F');
    executor.executeCommand('M');
    
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 3);  // 加速状态前进2格 + 正常状态前进1格
    EXPECT_EQ(heading, 'N');
}

// 测试批量指令
TEST(ExecutorTest, BatchCommands) {
    Executor executor;
    executor.executeBatchCommands("FMLR");
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 2);
    EXPECT_EQ(y, 3);
    EXPECT_EQ(heading, 'N');
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

### 5.2 测试结果
```
[==========] Running 5 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 5 tests from ExecutorTest
[ RUN      ] ExecutorTest.Accelerate
[       OK ] ExecutorTest.Accelerate (0 ms)
[ RUN      ] ExecutorTest.AccelerateTurnLeft
[       OK ] ExecutorTest.AccelerateTurnLeft (0 ms)
[ RUN      ] ExecutorTest.AccelerateTurnRight
[       OK ] ExecutorTest.AccelerateTurnRight (0 ms)
[ RUN      ] ExecutorTest.AccelerateToggle
[       OK ] ExecutorTest.AccelerateToggle (0 ms)
[ RUN      ] ExecutorTest.BatchCommands
[       OK ] ExecutorTest.BatchCommands (0 ms)
[----------] 5 tests from ExecutorTest (0 ms total)

[----------] Global test environment tear-down.
[==========] 5 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 5 tests.
```

---

## 六、实验总结

### 6.1 实现功能
1. ✅ 成功实现了Executor类的加速功能
2. ✅ 实现了加速指令F，支持进入和退出加速状态
3. ✅ 加速状态下，前进指令M移动2格
4. ✅ 加速状态下，左转指令L先前进1格再左转90度
5. ✅ 加速状态下，右转指令R先前进1格再右转90度
6. ✅ 使用Google Test完成了所有功能的单元测试

### 6.2 关键技术点
1. **状态管理**：使用布尔变量is_accelerated_管理加速状态
2. **状态切换**：通过F指令实现加速状态的切换
3. **条件逻辑**：根据加速状态执行不同的操作
4. **功能扩展**：在现有代码基础上扩展新功能，保持代码的可维护性

### 6.3 存在的问题与改进方向
1. **状态组合**：可以考虑支持更多的状态组合
2. **错误处理**：可以增加对异常指令的处理
3. **测试覆盖率**：可以增加更多边界条件的测试用例

---

## 七、参考文献
1. C++ Primer Plus (第6版)
2. Google Test官方文档
3. CMake官方文档

---

**实验报告撰写完成**
**日期：** 2025年12月14日