# C++面向对象编程实验报告

## 实验名称：车辆执行器设计与实现

## 学号：[请填写学号]
## 姓名：[请填写姓名]
## 实验日期：2025年12月14日

---

## 一、实验目的
1. 掌握C++面向对象编程的基本概念和方法
2. 理解和应用继承与多态的设计模式
3. 学习使用Google Test进行单元测试
4. 实现一个支持多种车辆类型的执行器系统

---

## 二、实验环境
- **操作系统**：Windows 10
- **开发工具**：Visual Studio 2019 / CLion
- **编程语言**：C++14
- **测试框架**：Google Test 1.11.0
- **构建工具**：CMake 3.10+

---

## 三、实验内容与要求

### 3.1 需求分析
设计一个车辆执行器系统，支持以下功能：
1. 支持多种车辆类型（跑车、公交车等）
2. 每种车辆类型具有不同的移动和转向行为
3. 支持基本的指令（前进、左转、右转）
4. 支持批量指令执行
5. 支持车辆类型的动态切换

### 3.2 设计思路
采用面向对象的设计方法：
1. **抽象基类**：定义Vehicle基类，包含纯虚函数moveForward、turnLeft、turnRight
2. **派生类**：实现不同车辆类型的具体行为
3. **执行器**：设计Executor类，负责解析指令并调用相应的车辆方法
4. **多态**：通过基类指针实现不同车辆类型的动态切换和行为调用

---

## 四、代码实现

### 4.1 Vehicle基类 (vehicle.h)
```cpp
#pragma once

#include <string>

// 车辆类型枚举
enum class VehicleType {
    SPORTS_CAR,
    BUS
};

// 车辆基类
class Vehicle {
public:
    virtual ~Vehicle() = default;
    
    // 设置位置和朝向
    void setPosition(int32_t x, int32_t y, char heading) {
        x_ = x;
        y_ = y;
        heading_ = heading;
    }
    
    // 获取当前位置和朝向
    void getPosition(int32_t& x, int32_t& y, char& heading) const {
        x = x_;
        y = y_;
        heading = heading_;
    }
    
    // 执行前进指令 - 纯虚函数，由子类实现
    virtual void moveForward() = 0;
    
    // 执行左转指令 - 纯虚函数，由子类实现
    virtual void turnLeft() = 0;
    
    // 执行右转指令 - 纯虚函数，由子类实现
    virtual void turnRight() = 0;
    
protected:
    int32_t x_ = 0;
    int32_t y_ = 0;
    char heading_ = 'N';
    
    // 辅助方法：实际的前进1格操作
    void actualMoveForward() {
        switch (heading_) {
            case 'N': y_ += 1; break;
            case 'E': x_ += 1; break;
            case 'S': y_ -= 1; break;
            case 'W': x_ -= 1; break;
        }
    }
    
    // 辅助方法：实际的左转90度操作
    void actualTurnLeft() {
        switch (heading_) {
            case 'N': heading_ = 'W'; break;
            case 'W': heading_ = 'S'; break;
            case 'S': heading_ = 'E'; break;
            case 'E': heading_ = 'N'; break;
        }
    }
    
    // 辅助方法：实际的右转90度操作
    void actualTurnRight() {
        switch (heading_) {
            case 'N': heading_ = 'E'; break;
            case 'E': heading_ = 'S'; break;
            case 'S': heading_ = 'W'; break;
            case 'W': heading_ = 'N'; break;
        }
    }
};
```

### 4.2 跑车类 (vehicle.h 部分)
```cpp
// 跑车类
class SportsCar : public Vehicle {
public:
    // 跑车的前进：1次移动2格
    void moveForward() override {
        actualMoveForward();
        actualMoveForward();
    }
    
    // 跑车的左转：先左转90度，再前进1格
    void turnLeft() override {
        actualTurnLeft();
        actualMoveForward();
    }
    
    // 跑车的右转：先右转90度，再前进1格
    void turnRight() override {
        actualTurnRight();
        actualMoveForward();
    }
};
```

### 4.3 公交车类 (vehicle.h 部分)
```cpp
// Bus类
class Bus : public Vehicle {
public:
    // Bus的前进：1次移动1格
    void moveForward() override {
        actualMoveForward();
    }
    
    // Bus的左转：先前进1格，再左转90度
    void turnLeft() override {
        actualMoveForward();
        actualTurnLeft();
    }
    
    // Bus的右转：先前进1格，再右转90度
    void turnRight() override {
        actualMoveForward();
        actualTurnRight();
    }
};
```

### 4.4 执行器类 (executor.h)
```cpp
#pragma once

#include "vehicle.h"
#include <string>
#include <memory>

class Executor {
public:
    // 构造函数，默认创建跑车类型
    Executor(VehicleType type = VehicleType::SPORTS_CAR);
    
    // 初始化接口，设置车的位置和朝向
    void initialize(int32_t x, int32_t y, char heading);
    
    // 执行单个指令
    void executeCommand(char command);
    
    // 执行批量指令
    void executeBatchCommands(const std::string& commands);
    
    // 查询当前位置和朝向
    void getCurrentState(int32_t& x, int32_t& y, char& heading) const;
    
    // 切换车辆类型
    void setVehicleType(VehicleType type);
    
private:
    // 创建车辆对象
    void createVehicle(VehicleType type);
    
    std::unique_ptr<Vehicle> vehicle_; // 车辆对象指针
    VehicleType current_type_;         // 当前车辆类型
};
```

### 4.5 执行器实现 (executor.cpp)
```cpp
#include "executor.h"

Executor::Executor(VehicleType type) {
    current_type_ = type;
    createVehicle(type);
}

void Executor::createVehicle(VehicleType type) {
    switch (type) {
        case VehicleType::SPORTS_CAR:
            vehicle_ = std::make_unique<SportsCar>();
            break;
        case VehicleType::BUS:
            vehicle_ = std::make_unique<Bus>();
            break;
    }
}

void Executor::initialize(int32_t x, int32_t y, char heading) {
    vehicle_->setPosition(x, y, heading);
}

void Executor::executeCommand(char command) {
    switch (command) {
        case 'M':
            vehicle_->moveForward();
            break;
        case 'L':
            vehicle_->turnLeft();
            break;
        case 'R':
            vehicle_->turnRight();
            break;
    }
}

void Executor::executeBatchCommands(const std::string& commands) {
    for (char command : commands) {
        executeCommand(command);
    }
}

void Executor::getCurrentState(int32_t& x, int32_t& y, char& heading) const {
    vehicle_->getPosition(x, y, heading);
}

void Executor::setVehicleType(VehicleType type) {
    if (current_type_ != type) {
        // 保存当前位置和朝向
        int32_t x, y;
        char heading;
        vehicle_->getPosition(x, y, heading);
        
        // 创建新类型的车辆
        createVehicle(type);
        current_type_ = type;
        
        // 恢复位置和朝向
        vehicle_->setPosition(x, y, heading);
    }
}
```

---

## 五、测试结果

### 5.1 Google Test测试用例
```cpp
#include <gtest/gtest.h>
#include "executor.h"

// 测试跑车的前进指令
TEST(SportsCarTest, MoveForward) {
    Executor executor(VehicleType::SPORTS_CAR);
    
    // 跑车前进：1次移动2格
    executor.executeCommand('M');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 2); // 跑车前进2格
    EXPECT_EQ(heading, 'N');
}

// 测试跑车的左转指令
TEST(SportsCarTest, TurnLeft) {
    Executor executor(VehicleType::SPORTS_CAR);
    
    // 跑车左转：先左转90度，再前进1格
    executor.executeCommand('L');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 初始状态：(0,0,N)
    // 左转90度 → (0,0,W)
    // 前进1格 → (-1,0,W)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'W');
}

// 测试跑车的右转指令
TEST(SportsCarTest, TurnRight) {
    Executor executor(VehicleType::SPORTS_CAR);
    
    // 跑车右转：先右转90度，再前进1格
    executor.executeCommand('R');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 初始状态：(0,0,N)
    // 右转90度 → (0,0,E)
    // 前进1格 → (1,0,E)
    EXPECT_EQ(x, 1);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'E');
}

// 测试Bus的前进指令
TEST(BusTest, MoveForward) {
    Executor executor(VehicleType::BUS);
    
    // Bus前进：1次移动1格
    executor.executeCommand('M');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 1); // Bus前进1格
    EXPECT_EQ(heading, 'N');
}

// 测试Bus的左转指令
TEST(BusTest, TurnLeft) {
    Executor executor(VehicleType::BUS);
    
    // Bus左转：先前进1格，再左转90度
    executor.executeCommand('L');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 初始状态：(0,0,N)
    // 前进1格 → (0,1,N)
    // 左转90度 → (0,1,W)
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'W');
}

// 测试Bus的右转指令
TEST(BusTest, TurnRight) {
    Executor executor(VehicleType::BUS);
    
    // Bus右转：先前进1格，再右转90度
    executor.executeCommand('R');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 初始状态：(0,0,N)
    // 前进1格 → (0,1,N)
    // 右转90度 → (0,1,E)
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'E');
}

// 测试批量指令执行
TEST(VehicleTest, BatchCommands) {
    // 测试跑车的批量指令
    Executor sportsCarExecutor(VehicleType::SPORTS_CAR);
    sportsCarExecutor.executeBatchCommands("MLR");
    int32_t x, y;
    char heading;
    sportsCarExecutor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 初始状态：(0,0,N)
    // M → (0,2,N)
    // L → 左转90度 → (0,2,W)，前进1格 → (-1,2,W)
    // R → 右转90度 → (-1,2,N)，前进1格 → (-1,3,N)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 3);
    EXPECT_EQ(heading, 'N');
    
    // 测试Bus的批量指令
    Executor busExecutor(VehicleType::BUS);
    busExecutor.executeBatchCommands("MLR");
    busExecutor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 初始状态：(0,0,N)
    // M → (0,1,N)
    // L → 前进1格 → (0,2,N)，左转90度 → (0,2,W)
    // R → 前进1格 → (-1,2,W)，右转90度 → (-1,2,N)
    EXPECT_EQ(x, -1);
    EXPECT_EQ(y, 2);
    EXPECT_EQ(heading, 'N');
}

// 测试车辆类型切换
TEST(VehicleTest, SwitchVehicleType) {
    Executor executor(VehicleType::SPORTS_CAR);
    
    // 初始为跑车，前进2格
    executor.executeCommand('M');
    
    // 切换为Bus
    executor.setVehicleType(VehicleType::BUS);
    
    // Bus前进1格
    executor.executeCommand('M');
    
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    
    // 预期结果：
    // 跑车前进2格 → (0,2,N)
    // 切换为Bus后位置不变 → (0,2,N)
    // Bus前进1格 → (0,3,N)
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 3);
    EXPECT_EQ(heading, 'N');
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

### 5.2 测试结果
```
[==========] Running 8 tests from 3 test suites.
[----------] Global test environment set-up.
[----------] 3 tests from SportsCarTest
[ RUN      ] SportsCarTest.MoveForward
[       OK ] SportsCarTest.MoveForward (0 ms)
[ RUN      ] SportsCarTest.TurnLeft
[       OK ] SportsCarTest.TurnLeft (0 ms)
[ RUN      ] SportsCarTest.TurnRight
[       OK ] SportsCarTest.TurnRight (0 ms)
[----------] 3 tests from SportsCarTest (0 ms total)

[----------] 3 tests from BusTest
[ RUN      ] BusTest.MoveForward
[       OK ] BusTest.MoveForward (0 ms)
[ RUN      ] BusTest.TurnLeft
[       OK ] BusTest.TurnLeft (0 ms)
[ RUN      ] BusTest.TurnRight
[       OK ] BusTest.TurnRight (0 ms)
[----------] 3 tests from BusTest (0 ms total)

[----------] 2 tests from VehicleTest
[ RUN      ] VehicleTest.BatchCommands
[       OK ] VehicleTest.BatchCommands (0 ms)
[ RUN      ] VehicleTest.SwitchVehicleType
[       OK ] VehicleTest.SwitchVehicleType (0 ms)
[----------] 2 tests from VehicleTest (0 ms total)

[----------] Global test environment tear-down.
[==========] 8 tests from 3 test suites ran. (0 ms total)
[  PASSED  ] 8 tests.
```

---

## 六、实验总结

### 6.1 实现功能
1. ✅ 成功实现了Vehicle抽象基类和不同车辆类型的派生类
2. ✅ 实现了跑车和公交车的不同移动和转向行为
3. ✅ 实现了Executor类，支持指令解析和执行
4. ✅ 支持批量指令执行和车辆类型的动态切换
5. ✅ 使用Google Test完成了所有功能的单元测试

### 6.2 关键技术点
1. **继承与多态**：通过基类指针实现不同车辆类型的动态行为
2. **智能指针**：使用std::unique_ptr管理车辆对象的生命周期
3. **面向接口编程**：依赖抽象基类而非具体实现
4. **设计模式**：应用了策略模式和工厂模式的思想

### 6.3 存在的问题与改进方向
1. **错误处理**：当前实现没有完善的错误处理机制
2. **指令扩展**：可以扩展支持更多类型的指令
3. **车辆属性**：可以添加更多车辆属性（速度、燃料等）
4. **测试覆盖率**：可以增加更多边界条件的测试用例

---

## 七、参考文献
1. C++ Primer Plus (第6版)
2. Effective C++ (第3版)
3. Google Test官方文档
4. CMake官方文档

---

## 八、附录
### 8.1 CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.10)

# 设置项目名称
project(VehicleExecutorTest)

# 设置C++标准
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找Google Test库
find_package(GTest REQUIRED)

# 添加头文件目录
include_directories(${GTEST_INCLUDE_DIRS})

# 创建Vehicle库
add_library(vehicle vehicle.h)
set_target_properties(vehicle PROPERTIES LINKER_LANGUAGE CXX)

# 创建Executor库
add_library(executor executor.cpp)
target_link_libraries(executor vehicle)

# 创建测试可执行文件
add_executable(test_executor test_executor.cpp)
target_link_libraries(test_executor executor ${GTEST_LIBRARIES} ${GTEST_MAIN_LIBRARIES})

# 添加测试
enable_testing()
add_test(NAME VehicleExecutorTest COMMAND test_executor)
```

### 8.2 运行说明
1. 创建build目录并进入
2. 运行 `cmake ..` 生成项目文件
3. 运行 `cmake --build .` 编译项目
4. 运行测试 `./test_executor` 或 `ctest`

---

**实验报告撰写完成**
**日期：** 2025年12月14日