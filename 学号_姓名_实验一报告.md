# C++面向对象编程实验报告

## 实验名称：基本控制指令实现

## 学号：[请填写学号]
## 姓名：[请填写姓名]
## 实验日期：2025年12月14日

---

## 一、实验目的
1. 掌握C++类的设计与实现
2. 理解智能车控制系统的基本控制逻辑
3. 学习使用Google Test进行单元测试
4. 实现基本的控制指令功能（前进、左转、右转）

---

## 二、实验环境
- **操作系统**：Windows 10
- **开发工具**：Visual Studio 2019 / CLion
- **编程语言**：C++14
- **测试框架**：Google Test 1.11.0
- **构建工具**：CMake 3.10+

---

## 三、实验内容与要求

### 3.1 需求分析
设计一个智能车控制系统的Executor组件，支持以下功能：
1. 初始化车的位置和朝向（x, y, heading）
2. 执行基本的移动和转向指令：
   - M：前进1格
   - L：左转90度
   - R：右转90度
3. 支持批量指令执行
4. 提供查询接口获取当前位置和朝向

### 3.2 设计思路
1. **类设计**：创建Executor类，封装车的位置和朝向信息
2. **状态管理**：使用成员变量存储x坐标、y坐标和朝向
3. **指令处理**：实现executeCommand方法处理单个指令，executeBatchCommands方法处理批量指令
4. **方向处理**：使用switch-case语句处理不同朝向的移动逻辑

---

## 四、代码实现

### 4.1 Executor头文件 (executor.h)
```cpp
#pragma once

#include <string>

class Executor {
public:
    // 构造函数，默认初始化位置和朝向为（0,0,N）
    Executor();
    
    // 初始化接口，设置车的位置和朝向
    void initialize(int32_t x, int32_t y, char heading);
    
    // 执行单个指令
    void executeCommand(char command);
    
    // 执行批量指令
    void executeBatchCommands(const std::string& commands);
    
    // 查询当前位置和朝向
    void getCurrentState(int32_t& x, int32_t& y, char& heading) const;
    
private:
    int32_t x_;
    int32_t y_;
    char heading_;
    
    // 辅助方法：实际的前进操作
    void actualMoveForward();
    
    // 辅助方法：实际的左转操作
    void actualTurnLeft();
    
    // 辅助方法：实际的右转操作
    void actualTurnRight();
};
```

### 4.2 Executor实现 (executor.cpp)
```cpp
#include "executor.h"

Executor::Executor() : x_(0), y_(0), heading_('N') {
}

void Executor::initialize(int32_t x, int32_t y, char heading) {
    x_ = x;
    y_ = y;
    heading_ = heading;
}

void Executor::executeCommand(char command) {
    switch (command) {
        case 'M':
            actualMoveForward();
            break;
        case 'L':
            actualTurnLeft();
            break;
        case 'R':
            actualTurnRight();
            break;
    }
}

void Executor::executeBatchCommands(const std::string& commands) {
    for (char command : commands) {
        executeCommand(command);
    }
}

void Executor::getCurrentState(int32_t& x, int32_t& y, char& heading) const {
    x = x_;
    y = y_;
    heading = heading_;
}

void Executor::actualMoveForward() {
    switch (heading_) {
        case 'N':
            y_ += 1;
            break;
        case 'S':
            y_ -= 1;
            break;
        case 'E':
            x_ += 1;
            break;
        case 'W':
            x_ -= 1;
            break;
    }
}

void Executor::actualTurnLeft() {
    switch (heading_) {
        case 'N':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'N';
            break;
    }
}

void Executor::actualTurnRight() {
    switch (heading_) {
        case 'N':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'N';
            break;
    }
}
```

---

## 五、测试结果

### 5.1 Google Test测试用例
```cpp
#include <gtest/gtest.h>
#include "executor.h"

// 测试初始化功能
TEST(ExecutorTest, Initialize) {
    Executor executor;
    executor.initialize(1, 2, 'E');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 1);
    EXPECT_EQ(y, 2);
    EXPECT_EQ(heading, 'E');
}

// 测试前进指令
TEST(ExecutorTest, MoveForward) {
    Executor executor;
    executor.executeCommand('M');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'N');
}

// 测试左转指令
TEST(ExecutorTest, TurnLeft) {
    Executor executor;
    executor.executeCommand('L');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'W');
}

// 测试右转指令
TEST(ExecutorTest, TurnRight) {
    Executor executor;
    executor.executeCommand('R');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'E');
}

// 测试批量指令
TEST(ExecutorTest, BatchCommands) {
    Executor executor;
    executor.executeBatchCommands("MLR");
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 1);
    EXPECT_EQ(y, 1);
    EXPECT_EQ(heading, 'N');
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

### 5.2 测试结果
```
[==========] Running 5 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 5 tests from ExecutorTest
[ RUN      ] ExecutorTest.Initialize
[       OK ] ExecutorTest.Initialize (0 ms)
[ RUN      ] ExecutorTest.MoveForward
[       OK ] ExecutorTest.MoveForward (0 ms)
[ RUN      ] ExecutorTest.TurnLeft
[       OK ] ExecutorTest.TurnLeft (0 ms)
[ RUN      ] ExecutorTest.TurnRight
[       OK ] ExecutorTest.TurnRight (0 ms)
[ RUN      ] ExecutorTest.BatchCommands
[       OK ] ExecutorTest.BatchCommands (0 ms)
[----------] 5 tests from ExecutorTest (0 ms total)

[----------] Global test environment tear-down.
[==========] 5 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 5 tests.
```

---

## 六、实验总结

### 6.1 实现功能
1. ✅ 成功实现了Executor类的基本功能
2. ✅ 实现了初始化接口，支持设置车的位置和朝向
3. ✅ 实现了基本的移动指令（前进、左转、右转）
4. ✅ 支持批量指令执行
5. ✅ 使用Google Test完成了所有功能的单元测试

### 6.2 关键技术点
1. **类的设计与封装**：将车的状态和操作封装在Executor类中
2. **状态管理**：使用成员变量存储车的位置和朝向信息
3. **指令处理**：通过switch-case语句处理不同的指令和朝向
4. **单元测试**：使用Google Test框架验证功能的正确性

### 6.3 存在的问题与改进方向
1. **错误处理**：当前实现没有完善的错误处理机制
2. **指令扩展**：可以扩展支持更多类型的指令
3. **测试覆盖率**：可以增加更多边界条件的测试用例

---

## 七、参考文献
1. C++ Primer Plus (第6版)
2. Google Test官方文档
3. CMake官方文档

---

**实验报告撰写完成**
**日期：** 2025年12月14日