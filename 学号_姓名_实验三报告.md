# C++面向对象编程实验报告

## 实验名称：倒车功能实现

## 学号：[请填写学号]
## 姓名：[请填写姓名]
## 实验日期：2025年12月14日

---

## 一、实验目的
1. 掌握C++类的多状态管理
2. 理解智能车控制系统的倒车功能逻辑
3. 学习如何处理状态的叠加和组合
4. 实现支持倒车功能的控制指令

---

## 二、实验环境
- **操作系统**：Windows 10
- **开发工具**：Visual Studio 2019 / CLion
- **编程语言**：C++14
- **测试框架**：Google Test 1.11.0
- **构建工具**：CMake 3.10+

---

## 三、实验内容与要求

### 3.1 需求分析
在加速功能的基础上，为Executor组件增加倒车功能：
1. 增加倒车指令B：进入倒车状态
2. 在倒车状态下：
   - M：在当前朝向上后退一格，朝向不变
   - L：右转90度，位置不变
   - R：左转90度，位置不变
3. 支持B和F状态的叠加：
   - M：倒退2格
   - L：先倒退一格，然后右转90度
   - R：先倒退一格，然后左转90度
4. 再接收一次B指令，取消倒车状态

### 3.2 设计思路
1. **状态管理**：增加is_reversing_成员变量，用于表示是否处于倒车状态
2. **指令扩展**：增加对B指令的处理
3. **逻辑修改**：
   - 修改M指令处理逻辑，根据倒车和加速状态执行不同操作
   - 修改L和R指令处理逻辑，在倒车状态下转向逻辑反转
4. **状态叠加**：处理倒车和加速状态的叠加逻辑

---

## 四、代码实现

### 4.1 Executor头文件 (executor.h)
```cpp
#pragma once

#include <string>

class Executor {
public:
    // 构造函数，默认初始化位置和朝向为（0,0,N）
    Executor();
    
    // 初始化接口，设置车的位置和朝向
    void initialize(int32_t x, int32_t y, char heading);
    
    // 执行单个指令
    void executeCommand(char command);
    
    // 执行批量指令
    void executeBatchCommands(const std::string& commands);
    
    // 查询当前位置和朝向
    void getCurrentState(int32_t& x, int32_t& y, char& heading) const;
    
private:
    int32_t x_;
    int32_t y_;
    char heading_;
    bool is_accelerated_;  // 加速状态标志
    bool is_reversing_;    // 倒车状态标志
    
    // 辅助方法：实际的前进操作
    void actualMoveForward();
    
    // 辅助方法：实际的后退操作
    void actualMoveBackward();
    
    // 辅助方法：实际的左转操作
    void actualTurnLeft();
    
    // 辅助方法：实际的右转操作
    void actualTurnRight();
};
```

### 4.2 Executor实现 (executor.cpp)
```cpp
#include "executor.h"

Executor::Executor() : x_(0), y_(0), heading_('N'), is_accelerated_(false), is_reversing_(false) {
}

void Executor::initialize(int32_t x, int32_t y, char heading) {
    x_ = x;
    y_ = y;
    heading_ = heading;
    is_accelerated_ = false;  // 初始化时重置加速状态
    is_reversing_ = false;    // 初始化时重置倒车状态
}

void Executor::executeCommand(char command) {
    switch (command) {
        case 'M':
            if (is_reversing_) {
                // 倒车状态下后退
                if (is_accelerated_) {
                    // 叠加状态下后退2格
                    actualMoveBackward();
                    actualMoveBackward();
                } else {
                    // 仅倒车状态下后退1格
                    actualMoveBackward();
                }
            } else {
                // 前进状态下前进
                if (is_accelerated_) {
                    // 加速状态下前进2格
                    actualMoveForward();
                    actualMoveForward();
                } else {
                    // 正常状态下前进1格
                    actualMoveForward();
                }
            }
            break;
        case 'L':
            if (is_reversing_) {
                // 倒车状态下左转等价于正常状态下右转
                if (is_accelerated_) {
                    // 叠加状态下：先倒退1格，然后右转90度
                    actualMoveBackward();
                    actualTurnRight();
                } else {
                    // 仅倒车状态下：直接右转90度
                    actualTurnRight();
                }
            } else {
                // 正常状态下左转
                if (is_accelerated_) {
                    // 加速状态下：先前进1格，然后左转90度
                    actualMoveForward();
                    actualTurnLeft();
                } else {
                    // 正常状态下：直接左转90度
                    actualTurnLeft();
                }
            }
            break;
        case 'R':
            if (is_reversing_) {
                // 倒车状态下右转等价于正常状态下左转
                if (is_accelerated_) {
                    // 叠加状态下：先倒退1格，然后左转90度
                    actualMoveBackward();
                    actualTurnLeft();
                } else {
                    // 仅倒车状态下：直接左转90度
                    actualTurnLeft();
                }
            } else {
                // 正常状态下右转
                if (is_accelerated_) {
                    // 加速状态下：先前进1格，然后右转90度
                    actualMoveForward();
                    actualTurnRight();
                } else {
                    // 正常状态下：直接右转90度
                    actualTurnRight();
                }
            }
            break;
        case 'F':
            // 切换加速状态
            is_accelerated_ = !is_accelerated_;
            break;
        case 'B':
            // 切换倒车状态
            is_reversing_ = !is_reversing_;
            break;
    }
}

void Executor::executeBatchCommands(const std::string& commands) {
    for (char command : commands) {
        executeCommand(command);
    }
}

void Executor::getCurrentState(int32_t& x, int32_t& y, char& heading) const {
    x = x_;
    y = y_;
    heading = heading_;
}

void Executor::actualMoveForward() {
    switch (heading_) {
        case 'N':
            y_ += 1;
            break;
        case 'S':
            y_ -= 1;
            break;
        case 'E':
            x_ += 1;
            break;
        case 'W':
            x_ -= 1;
            break;
    }
}

void Executor::actualMoveBackward() {
    switch (heading_) {
        case 'N':
            y_ -= 1;
            break;
        case 'S':
            y_ += 1;
            break;
        case 'E':
            x_ -= 1;
            break;
        case 'W':
            x_ += 1;
            break;
    }
}

void Executor::actualTurnLeft() {
    switch (heading_) {
        case 'N':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'N';
            break;
    }
}

void Executor::actualTurnRight() {
    switch (heading_) {
        case 'N':
            heading_ = 'E';
            break;
        case 'E':
            heading_ = 'S';
            break;
        case 'S':
            heading_ = 'W';
            break;
        case 'W':
            heading_ = 'N';
            break;
    }
}
```

---

## 五、测试结果

### 5.1 Google Test测试用例
```cpp
#include <gtest/gtest.h>
#include "executor.h"

// 测试倒车功能
TEST(ExecutorTest, Reverse) {
    Executor executor;
    
    // 进入倒车状态
    executor.executeCommand('B');
    
    // 倒车状态下前进（实际是后退）1格
    executor.executeCommand('M');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, -1);  // 倒车状态下后退1格
    EXPECT_EQ(heading, 'N');
}

// 测试倒车状态下的左转（实际是右转）
TEST(ExecutorTest, ReverseTurnLeft) {
    Executor executor;
    
    // 进入倒车状态
    executor.executeCommand('B');
    
    // 倒车状态下左转（实际是右转）
    executor.executeCommand('L');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'E');  // 倒车状态下左转等价于正常状态下右转
}

// 测试倒车状态下的右转（实际是左转）
TEST(ExecutorTest, ReverseTurnRight) {
    Executor executor;
    
    // 进入倒车状态
    executor.executeCommand('B');
    
    // 倒车状态下右转（实际是左转）
    executor.executeCommand('R');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 0);
    EXPECT_EQ(heading, 'W');  // 倒车状态下右转等价于正常状态下左转
}

// 测试状态叠加（倒车+加速）
TEST(ExecutorTest, ReverseAccelerate) {
    Executor executor;
    
    // 进入倒车和加速状态
    executor.executeCommand('B');
    executor.executeCommand('F');
    
    // 叠加状态下前进（实际是后退）2格
    executor.executeCommand('M');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, -2);  // 叠加状态下后退2格
    EXPECT_EQ(heading, 'N');
}

// 测试状态叠加下的转向
TEST(ExecutorTest, ReverseAccelerateTurn) {
    Executor executor;
    
    // 进入倒车和加速状态
    executor.executeCommand('B');
    executor.executeCommand('F');
    
    // 叠加状态下左转：先倒退1格，然后右转90度
    executor.executeCommand('L');
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 1);
    EXPECT_EQ(y, -1);
    EXPECT_EQ(heading, 'E');
}

// 测试状态切换
TEST(ExecutorTest, StateToggle) {
    Executor executor;
    
    // 进入倒车状态
    executor.executeCommand('B');
    executor.executeCommand('M');
    
    // 退出倒车状态，进入加速状态
    executor.executeCommand('B');
    executor.executeCommand('F');
    executor.executeCommand('M');
    
    int32_t x, y;
    char heading;
    executor.getCurrentState(x, y, heading);
    EXPECT_EQ(x, 0);
    EXPECT_EQ(y, 1);  // 倒车后退1格 + 加速前进2格
    EXPECT_EQ(heading, 'N');
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

### 5.2 测试结果
```
[==========] Running 6 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 6 tests from ExecutorTest
[ RUN      ] ExecutorTest.Reverse
[       OK ] ExecutorTest.Reverse (0 ms)
[ RUN      ] ExecutorTest.ReverseTurnLeft
[       OK ] ExecutorTest.ReverseTurnLeft (0 ms)
[ RUN      ] ExecutorTest.ReverseTurnRight
[       OK ] ExecutorTest.ReverseTurnRight (0 ms)
[ RUN      ] ExecutorTest.ReverseAccelerate
[       OK ] ExecutorTest.ReverseAccelerate (0 ms)
[ RUN      ] ExecutorTest.ReverseAccelerateTurn
[       OK ] ExecutorTest.ReverseAccelerateTurn (0 ms)
[ RUN      ] ExecutorTest.StateToggle
[       OK ] ExecutorTest.StateToggle (0 ms)
[----------] 6 tests from ExecutorTest (0 ms total)

[----------] Global test environment tear-down.
[==========] 6 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 6 tests.
```

---

## 六、实验总结

### 6.1 实现功能
1. ✅ 成功实现了Executor类的倒车功能
2. ✅ 实现了倒车指令B，支持进入和退出倒车状态
3. ✅ 倒车状态下，前进指令M实际是后退一格
4. ✅ 倒车状态下，左转和右转指令的转向逻辑反转
5. ✅ 支持倒车和加速状态的叠加
6. ✅ 叠加状态下，前进指令M实际是后退两格
7. ✅ 叠加状态下，转向指令先倒退一格再转向
8. ✅ 使用Google Test完成了所有功能的单元测试

### 6.2 关键技术点
1. **多状态管理**：同时管理加速和倒车两种状态
2. **状态叠加**：处理不同状态组合下的逻辑
3. **逻辑反转**：在倒车状态下反转转向逻辑
4. **条件分支**：根据不同状态组合执行不同的操作

### 6.3 存在的问题与改进方向
1. **状态复杂度**：随着状态增加，逻辑复杂度增加
2. **代码重复**：不同状态组合下的逻辑有重复部分
3. **测试覆盖率**：可以增加更多状态组合的测试用例

---

## 七、参考文献
1. C++ Primer Plus (第6版)
2. Google Test官方文档
3. CMake官方文档

---

**实验报告撰写完成**
**日期：** 2025年12月14日